图：为什么使用图？
前面使用了线性表和树：线性表局限于一个直接前驱和直接后继的关系，树也只能有一个直接前驱也就是父节点，当我们需要表现多对多的关系时就用到了图

基本介绍：图是一种数据结构，其中节点可以具有多个零个或者多个相邻元素。两个节点之前的连接线称为边，节点也可以称为顶点。

图的表现方式：二维数组表示(邻接矩阵)；链表表示(邻接表)
    邻接矩阵：表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是row和col表示1...n个点。
    邻接表：邻接矩阵需要为每个顶点都分配n个边的空间，其实很多边都是不存在的，会造成空间上的一定损失。
    邻接表的实现只关注存在的边，不关心不存在的边，因此没有空间浪费，邻接表由数组+链表组成。

图的实现思路：
    使用ArrayList<String>存储顶点String
    保存矩阵使用二维数组int[][] edgs

图的遍历：图的遍历就是指对顶点的访问，一个图有那么多顶点，如何遍历这些顶点需要特定的策略，一般有两种策略：图的深度遍历和图的广度遍历
    图的深度优先搜索：递归
        1.从初顶点开始找出跟初顶点相邻的第一个顶点
        2.判断这个顶点是否已经遍历过，遍历过就跳过这个顶点找到下一个相邻的顶点。
        3.找到没有遍历且相邻顶点之后，再用这个相邻顶点继续重复2-3
        4.直到到达最后一个顶点，如果顶点已经遍历过就退出，如此递归就完成先深后广(迷宫和八皇后问题)
    图的广度优先搜索：分层搜索，先完成一层再继续这层找到的顶点的下一层
        1.从初顶点开始找出跟初顶点相邻的第一个顶点
        2.将这个顶点放入建造好的队列中
        3.判断队列是否为空，不为空就取出一个顶点(刚开始就是第一个相邻顶点)
        4.找到这个顶点的所有相邻的顶点，记录到链表，并且把这个找到的顶点设置为遍历过，继续重复3-4
        5.队列为空了就完成了一个广度再深的遍历
注意：多看代码！！！！