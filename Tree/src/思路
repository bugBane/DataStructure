二叉树：
为什么需要树这种数据结构？
1.数组分析：
    优点：通过下标访问元素，速度快，对于有序数组还可以使用二分查找提高检索速度。
    缺点：如果要检索某一个值或者插入值(按一定顺序)会整体移动，效率较低
2.链式存储分析：
    优点：在一定程度上对数组存储方式有优化(比如插入一个节点，只需要将该节点链接到链表中即可；删除效率也很高)
    缺点：在进行检索时，效率仍然较低(比如检索某个值需要从头节点开始遍历)
3.树存储分析：
    能提高数据存储和读取的效率(比如利用二叉排序树，既可以保证数据的检索速度，同时也可以保证数据的插入，修改，删除速度)

树的常用术语：
    节点
    根节点
    父节点
    子节点
    叶子节点(没有子节点的节点)
    节点的权(节点值)
    路径(从root节点找到该节点的路线)
    层
    子树
    树的高度(最大层数)
    森林：多棵子树构成森林

二叉树的概念：
    树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。
    二叉树的子节点分为左节点和右节点。
    如果该二叉树的所有子节点都在最后一层，并且节点总数=2^n-1,n为层数,则我们称为满二叉树。
    如果该二叉树的所有子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。
二叉树遍历：使用前序、中序和后序对二叉树进行遍历。
    前序遍历：先输出父节点，再遍历左子树和右子树。
    中序遍历：先遍历左子树，再输出父节点，再遍历右子树。
    后序遍历：先遍历左子树，再遍历右子树，再输出父节点。
    小结：看输出父节点的顺序，就确定是前序中序和后序。
二叉树查找：使用前序、中序和后序对二叉树进行查找。
    前序查找：先判断父节点，再查找左子树和右子树。
    中序查找：先查找左子树，再判断父节点，再查找右子树。
    后序查找：先查找左子树，再查找右子树，再判断父节点。
    注意：与遍历不同的是，查找左树与右树时需要返回节点判断是否为空，不为空才能返回，为空继续向下查找。(如果不判断为空，那么只递归完左树就返回null结束)！！！
二叉树删除：注意删除节点需要借助上一个节点
    如果是叶子节点，将叶子节点置为null
    如果是子节点，将子节点置为null
    如果是root，将树置为null

顺序二叉树：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组。
    数组：{1, 2, 3, 4, 5, 6, 7}
    顺序二叉树：        1
                2           3
            4       5   6       7
    要求：数据用数组的方式存储，但是用前序遍历、中序遍历和后序遍历的方式完成节点的遍历。
    特点：
        顺序二叉树通常只考虑完全二叉树！！！
        第n个元素的左子节点为2*n+1;右子节点为2*n+2;父节点为(n-1)/2;(其中n表示二叉树中第几个元素,从0开始编号[数组索引])

线索化二叉树：
    n个节点的二叉链表含有n+1【公式：2*n-(n-1)】个指针域。利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针(这种附加的指针称为线索)
    这种加了线索的二叉链表称为线索链表，相应的二叉树被称为线索二叉树。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后续线索二叉树三种。
    一个节点被遍历的前一个节点称为这个节点的前驱节点，之后遍历的后一个节点为该节点的后继节点。
    注意：前驱节点和左子节点共用left/后继节点和右子节点共用right，所以left/right可能指向左子节点/右子节点，或者前驱节点/后继节点。
优势：(注意：使用堆栈的思想也是递归思想！！！)
可以用来中序遍历：当你构造好了线索二叉树了之后，从根节点开始，如果当前节点有左子节点就去左子节点，没有左子节点的话，就通过右边去下一个节点，这样不用递归就可以完成二叉树的中序遍历。
    (1)利用线索二叉树进行中序遍历时，不必采用堆栈处理，速度较一般二叉树的遍历速度快，且节约存储空间。
    (2)任意一个结点都能直接找到它的前驱和后继结点。
不足：
    (1)结点的插入和删除麻烦，且速度也较慢。
    (2)线索子树不能共用。

树结构的实际应用：
1.堆排序：堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
堆是有以下性质的完全二叉树：
    每个节点的值都大于等于其左右孩子节点的值，称为大顶堆。注意：没有要求节点的左孩子的值和右孩子的值的大小关系。
    每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。
大顶堆特点：arr[i]>=arr[2*i+1]&&arr[i]>=arr[2*i+2] //i对应第几个节点，i从0开始编号
    数组：{50, 45, 40, 20, 25, 35, 30, 10, 15}
    顺序二叉树(大顶堆)：             50
                            45          40
                        20      25  35      30
                    10      15
小顶堆特点：arr[i]<=arr[2*i+1]&&arr[i]<=arr[2*i+2] //i对应第几个节点，i从0开始编号
    顺序二叉树(小顶堆)：             10
                            20          15
                        25      50  30      40
                    35      45
一般升序使用大顶堆，降序使用小顶堆。
堆排序的基本思想：
    将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。
    然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素次小值，如此反复执行，便能得到一个有序序列。
