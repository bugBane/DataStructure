二叉树：
为什么需要树这种数据结构？
1.数组分析：
    优点：通过下标访问元素，速度快，对于有序数组还可以使用二分查找提高检索速度。
    缺点：如果要检索某一个值或者插入值(按一定顺序)会整体移动，效率较低
2.链式存储分析：
    优点：在一定程度上对数组存储方式有优化(比如插入一个节点，只需要将该节点链接到链表中即可；删除效率也很高)
    缺点：在进行检索时，效率仍然较低(比如检索某个值需要从头节点开始遍历)
3.树存储分析：
    能提高数据存储和读取的效率(比如利用二叉排序树，既可以保证数据的检索速度，同时也可以保证数据的插入，修改，删除速度)

树的常用术语：
    节点
    根节点
    父节点
    子节点
    叶子节点(没有子节点的节点)
    节点的权(节点值)
    路径(从root节点找到该节点的路线)
    层
    子树
    树的高度(最大层数)
    森林：多棵子树构成森林

二叉树的概念：
    树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。
    二叉树的子节点分为左节点和右节点。
    如果该二叉树的所有子节点都在最后一层，并且节点总数=2^n-1,n为层数,则我们称为满二叉树。
    如果该二叉树的所有子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。
二叉树遍历：使用前序、中序和后序对二叉树进行遍历。
    前序遍历：先输出父节点，再遍历左子树和右子树。
    中序遍历：先遍历左子树，再输出父节点，再遍历右子树。
    后序遍历：先遍历左子树，再遍历右子树，再输出父节点。
    小结：看输出父节点的顺序，就确定是前序中序和后序。
二叉树查找：使用前序、中序和后序对二叉树进行查找。
    前序查找：先判断父节点，再查找左子树和右子树。
    中序查找：先查找左子树，再判断父节点，再查找右子树。
    后序查找：先查找左子树，再查找右子树，再判断父节点。
    注意：与遍历不同的是，查找左树与右树时需要返回节点判断是否为空，不为空才能返回，为空继续向下查找。(如果不判断为空，那么只递归完左树就返回null结束)！！！
二叉树删除：注意删除节点需要借助上一个节点
    如果是叶子节点，将叶子节点置为null
    如果是子节点，将子节点置为null
    如果是root，将树置为null

顺序二叉树：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组。
    数组：{1, 2, 3, 4, 5, 6, 7}
    顺序二叉树：        1
                2           3
            4       5   6       7
    要求：数据用数组的方式存储，但是用前序遍历、中序遍历和后序遍历的方式完成节点的遍历。
    特点：
        顺序二叉树通常只考虑完全二叉树！！！
        第n个元素的左子节点为2*n+1;右子节点为2*n+2;父节点为(n-1)/2;(其中n表示二叉树中第几个元素,从0开始编号[数组索引])

线索化二叉树：
    n个节点的二叉链表含有n+1【公式：2*n-(n-1)】个指针域。利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针(这种附加的指针称为线索)
    这种加了线索的二叉链表称为线索链表，相应的二叉树被称为线索二叉树。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后续线索二叉树三种。
    一个节点被遍历的前一个节点称为这个节点的前驱节点，之后遍历的后一个节点为该节点的后继节点。
    注意：前驱节点和左子节点共用left/后继节点和右子节点共用right，所以left/right可能指向左子节点/右子节点，或者前驱节点/后继节点。
优势：(注意：使用堆栈的思想也是递归思想！！！)
可以用来中序遍历：当你构造好了线索二叉树了之后，从根节点开始，如果当前节点有左子节点就去左子节点，没有左子节点的话，就通过右边去下一个节点，这样不用递归就可以完成二叉树的中序遍历。
    (1)利用线索二叉树进行中序遍历时，不必采用堆栈处理，速度较一般二叉树的遍历速度快，且节约存储空间。
    (2)任意一个结点都能直接找到它的前驱和后继结点。
不足：
    (1)结点的插入和删除麻烦，且速度也较慢。
    (2)线索子树不能共用。

树结构的实际应用：
1.堆排序：堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
堆是有以下性质的完全二叉树：
    每个节点的值都大于等于其左右孩子节点的值，称为大顶堆。注意：没有要求节点的左孩子的值和右孩子的值的大小关系。
    每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。
大顶堆特点：arr[i]>=arr[2*i+1]&&arr[i]>=arr[2*i+2] //i对应第几个节点，i从0开始编号
    数组：{50, 45, 40, 20, 25, 35, 30, 10, 15}
    顺序二叉树(大顶堆)：             50
                            45          40
                        20      25  35      30
                    10      15
小顶堆特点：arr[i]<=arr[2*i+1]&&arr[i]<=arr[2*i+2] //i对应第几个节点，i从0开始编号
    顺序二叉树(小顶堆)：             10
                            20          15
                        25      50  30      40
                    35      45
一般升序使用大顶堆，降序使用小顶堆。
堆排序的基本思想：
    将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。
    然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素次小值，如此反复执行，便能得到一个有序序列。

赫夫曼树：
    基本介绍：
        给定n个权值作为n个节点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树；
        哈夫曼树是树带权路径长度最短的树，权值较大的节点离根较近。
    概念：
        路径和路径长度：在一棵树中，从一个节点往下可以达到的孩子或者孙子节点之间的通路称为路径。通路中分支的数目称为路径长度。
        若规定根节点的层数为1，则从根节点到L层节点的路径长度为L-1。
        节点的权：若将树中结点赋给一个有着某种含义的值，则这个数值称为该节点的权。
        节点的带权路径长度：从根节点到该节点之间的路径长度与该节点权的乘积。
        树的带权路径长度：树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为WPL，权值越大的节点离根节点越近的二叉树才是最优二叉树。
        WPL最小的就是赫夫曼树。
    步：骤：
        1.从小到大进行排序，将每一个数据创建为一个节点，每个节点可以看成是简单的二叉树；
        2.取出根节点权值最小的两颗二叉树，组成一颗新的二叉树，该新的二叉树根节点是前面两颗二叉树根节点权值的和；
        3.再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3的步骤，直到数列中所有的数据被处理，就得到一颗赫夫曼树。

赫夫曼编码：因为赫夫曼树是最优的权值路径树，所以可以用来压缩
    最佳实践：文件压缩-文件解压
    注意事项：
        1.如果文件本身就是经过压缩处理的，那么使用赫夫曼编码在压缩效率不会有明显的变化，比如视频、ppt等
        2.赫夫曼编码是按字节来处理的，因此可以处理所有的文件
        3.如果一个文件中的内容，重复的内容不多，压缩效果也不会很明显

二叉排序树：
    特征：
        左节点<父节点<右节点；
        如果存在重复元素添加，那么相当于修改，比如hashMap的put方法，底层是 数组+红黑树(二叉排序树) key就不能重复
    增删改查：
        增/改：判断元素值，相等就去修改
            小于继续判断左节点，左节点为空，添加，否则继续判断左节点的节点(递归);
            大于继续判断右节点，右节点为空，添加，否则继续判断右节点的节点(递归);
        查/遍历：中序遍历/判断就行
        删：比较麻烦，重中之重！！！主要是三种情况删除：
            1.删除节点为叶子节点：直接用父节点删除就行
            2.删除节点只有左节点或者右节点： 2*2=4种判断
                要判断父节点是否为空，有可能是删除根节点，那么就不用这么麻烦，直接根节点=左节点或者右节点
                否则再判断该节点是父节点的左节点还是右节点：如果为左节点那么父左节点直接连接该节点的左节点或者右节点；如果为右节点那么父右节点直接连接该节点的左节点或者右节点
            3.删除节点为节点树，使用替换的思路：该节点右节点的最小节点值替换该节点，删除最小节点
            (详细代码看平衡二叉树)

平衡二叉树：难点在于平衡(左旋、右旋、双旋)
    特征：二叉排序树的一种，全名平衡二叉搜索树
        左节点<父节点<右节点；
        如果存在重复元素添加，那么相当于修改，比如hashMap的put方法，底层是 数组+红黑树(二叉排序树) key就不能重复
        树的高度与叶子节点的最小高度不超过1(最大高度与最小高度不超过1)
    增删改查：与二叉排序树类似，只是增删之后会有平衡树的操作
    平衡：左旋、右旋、双旋
        左旋：右子树高度比左子树高
        右旋：左子树高度比右子树高
        双旋：右子树高度比左子树高，但是右子树的左子树高度比右子树的右子树高度，需要先右旋调整到外边再左旋
        // 平衡二叉树
        public void balanceALVTree() {
            // (要左旋或者右旋前提是要左旋的右节点是平衡的或者要右旋的左节点是平衡的，如果不平衡那么旋转之后还是不平衡)
            if (getRightHeight() - getLeftHeight() > 1) {
                // 左旋时如果右节点不平衡(右节点的左节点高于右节点的左节点，先右旋右节点保持右节点平衡)
                if (this.right != null && this.right.getLeftHeight() > this.right.getRightHeight()) {
                    this.right.dextroRotation();
                }
                // 左旋
                levoRotation();
                // 添加是一个一个的添加，此时处理完了之后就证明这一个添加完毕了
                return;
            }
            if (getLeftHeight() - getRightHeight() > 1) {
                // 右旋时如果左节点不平衡(左节点的右节点高于左节点的左节点，先左旋左节点保持左节点平衡)
                if (this.left != null && this.left.getRightHeight() > this.left.getLeftHeight()) {
                    this.left.levoRotation();
                }
                // 右旋
                dextroRotation();
            }
        }
        // 左旋
        public void levoRotation() {
            // 定义一个中间节点
            ALVNode temp = new ALVNode(this.value);
            // 中间节点的左节点为原节点的左节点
            temp.left = this.left;
            // 中间节点的右节点为原节点的右节点的左节点
            temp.right = this.right.left;
            // 此时已经构建好了一个temp节点，只需要将原节点左移(只是修改了值，原节点的结构没有发生变化，需要将原结构重新调整)
            this.value = this.right.value;
            // 新左移节点连接左节点(使用原节点)
            this.left = temp;
            // 新左移点节点连接右节点(使用原节点)
            this.right = this.right.right;
            // 执行完之后就相当于将原节点重新构建成一个新的左移节点
            // 原节点左移过程中只是修改值，所以左移之前的原节点的右节点还存在，但是没有任何节点指向它，会被gc回收(虽然它连接其它节点但是可达性分析并不能找到)
        }
        // 右旋
        public void dextroRotation() {
            // 定义一个中间节点
            ALVNode temp = new ALVNode(this.value);
            // 中间节点的右节点为原节点的右节点
            temp.right = this.right;
            // 中间节点的左节点为原节点的左节点的右节点
            temp.left = this.left.right;
            // 此时已经构建好了一个temp节点，只需要将原节点右移(只是修改了值，原节点的结构没有发生变化，需要将原结构重新调整)
            this.value = this.left.value;
            // 新右移节点连接左节点
            this.right = temp;
            // 新右移点节点连接右节点(原节点结构没有发生变化)
            this.left = this.left.left;
            // 执行完之后就相当于将原节点重新构建成一个新的左移节点
            // 原节点右移过程中只是修改值，所以右移之前的原节点的左节点还存在，但是没有任何节点指向它，会被gc回收(虽然它连接其它节点但是可达性分析并不能找到)
        }

二叉树的问题分析：二叉树操作效率高但是也会存在问题
    二叉树需要加载到内存，如果二叉树的节点少，那么不会有什么问题，如果二叉树节点很多那么就可能带来如下问题：
    1.构建二叉树时，需要多次进行io操作(海量数据存在数据库或者文件中)，节点海量，构建二叉树时速度有影响。
    2.节点海量会造成二叉树的高度很高，降低操作速度。
多叉树：
    概念：在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点有更多的数据项和更多的子节点，就是多叉树。多叉树通过减少树的高度，能对二叉树进行优化。
    常见：B树、2-3树、2-3-4树就是多叉树
B树：就是多叉树，通过重新组织节点降低树的高度，并且减少i/o读写次数来提升效率。
    文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次i/o就可以完全载入。
    将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树(B+)广泛应用于文件存储系统以及数据库系统中
2-3树：
    特点：
        2-3树的所有叶子节点都在同一层(只要是B树都满足这个结构)
        有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点
        有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
        2-3节点是由二节点和三节点构成的树
    插入规则：
        添加一个数据时如果不能满足上边的特点，就需要拆，先向上拆，如果上层满则拆本层，拆后仍然需要满足上边特点。
2-3-4树：和2-3特点一样，就是多了一个四节点
B+树：B+树是B树的变体，也是一种多路搜索树。更适合文件索引系统，各有各的应用场景，不能说谁好谁坏(切记不能非好即坏，矛盾论和实践论相结合)
    B+树的搜索与B树基本相同，区别是B+树只有到达叶子节点才能命中(B树非叶子节点命中)，其性能也等价于在关键字全集做一次二分查找
    所有关键字都出现在叶子节点的链表中(数据只能在叶子节点，也叫稠密索引)，且链表中的关键字恰好是有序的。
    不可能在非叶子节点命中
    非叶子节点相当于叶子节点的索引(稀疏索引)，叶子节点相当于是存储(关键字)数据的数据层
B*树：B*树是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针。
    B*树规定了非叶子节点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为1/2。块使用率更高