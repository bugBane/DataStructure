二叉树：
为什么需要树这种数据结构？
1.数组分析：
    优点：通过下标访问元素，速度快，对于有序数组还可以使用二分查找提高检索速度。
    缺点：如果要检索某一个值或者插入值(按一定顺序)会整体移动，效率较低
2.链式存储分析：
    优点：在一定程度上对数组存储方式有优化(比如插入一个节点，只需要将该节点链接到链表中即可；删除效率也很高)
    缺点：在进行检索时，效率仍然较低(比如检索某个值需要从头节点开始遍历)
3.树存储分析：
    能提高数据存储和读取的效率(比如利用二叉排序树，既可以保证数据的检索速度，同时也可以保证数据的插入，修改，删除速度)

树的常用术语：
    节点
    根节点
    父节点
    子节点
    叶子节点(没有子节点的节点)
    节点的权(节点值)
    路径(从root节点找到该节点的路线)
    层
    子树
    树的高度(最大层数)
    森林：多棵子树构成森林

二叉树的概念：
    树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。
    二叉树的子节点分为左节点和右节点。
    如果该二叉树的所有子节点都在最后一层，并且节点总数=2^n-1,n为层数,则我们称为满二叉树。
    如果该二叉树的所有子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。
二叉树遍历：使用前序、中序和后序对二叉树进行遍历。
    前序遍历：先输出父节点，再遍历左子树和右子树。
    中序遍历：先遍历左子树，再输出父节点，再遍历右子树。
    后序遍历：先遍历左子树，再遍历右子树，再输出父节点。
    小结：看输出父节点的顺序，就确定是前序中序和后序。
二叉树查找：使用前序、中序和后序对二叉树进行查找。
    前序查找：先判断父节点，再查找左子树和右子树。
    中序查找：先查找左子树，再判断父节点，再查找右子树。
    后序查找：先查找左子树，再查找右子树，再判断父节点。
    注意：与遍历不同的是，查找左树与右树时需要返回节点判断是否为空，不为空才能返回，为空继续向下查找。(如果不判断为空，那么只递归完左树就返回null结束)！！！
二叉树删除：注意删除节点需要借助上一个节点
    如果是叶子节点，将叶子节点置为null
    如果是子节点，将子节点置为null
    如果是root，将树置为null

顺序二叉树：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组。
    数组：{1, 2, 3, 4, 5, 6, 7}
    顺序二叉树：        1
                2           3
            4       5   6       7
    要求：数据用数组的方式存储，但是用前序遍历、中序遍历和后序遍历的方式完成节点的遍历。
    特点：
        顺序二叉树通常只考虑完全二叉树！！！
        第n个元素的左子节点为2*n+1;右子节点为2*n+2;父节点为(n-1)/2;(其中n表示二叉树中第几个元素,从0开始编号[数组索引])

线索化二叉树：
    n个节点的二叉链表含有n+1【公式：2*n-(n-1)】个指针域。利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针(这种附加的指针称为线索)
    这种加了线索的二叉链表称为线索链表，相应的二叉树被称为线索二叉树。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后续线索二叉树三种。
    一个节点被遍历的前一个节点称为这个节点的前驱节点，之后遍历的后一个节点为该节点的后继节点。
    注意：前驱节点和左子节点共用left/后继节点和右子节点共用right，所以left/right可能指向左子节点/右子节点，或者前驱节点/后继节点。
优势：(注意：使用堆栈的思想也是递归思想！！！)
可以用来中序遍历：当你构造好了线索二叉树了之后，从根节点开始，如果当前节点有左子节点就去左子节点，没有左子节点的话，就通过右边去下一个节点，这样不用递归就可以完成二叉树的中序遍历。
    (1)利用线索二叉树进行中序遍历时，不必采用堆栈处理，速度较一般二叉树的遍历速度快，且节约存储空间。
    (2)任意一个结点都能直接找到它的前驱和后继结点。
不足：
    (1)结点的插入和删除麻烦，且速度也较慢。
    (2)线索子树不能共用。

树结构的实际应用：
1.堆排序：堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
堆是有以下性质的完全二叉树：
    每个节点的值都大于等于其左右孩子节点的值，称为大顶堆。注意：没有要求节点的左孩子的值和右孩子的值的大小关系。
    每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。
大顶堆特点：arr[i]>=arr[2*i+1]&&arr[i]>=arr[2*i+2] //i对应第几个节点，i从0开始编号
    数组：{50, 45, 40, 20, 25, 35, 30, 10, 15}
    顺序二叉树(大顶堆)：             50
                            45          40
                        20      25  35      30
                    10      15
小顶堆特点：arr[i]<=arr[2*i+1]&&arr[i]<=arr[2*i+2] //i对应第几个节点，i从0开始编号
    顺序二叉树(小顶堆)：             10
                            20          15
                        25      50  30      40
                    35      45
一般升序使用大顶堆，降序使用小顶堆。
堆排序的基本思想：
    将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。
    然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素次小值，如此反复执行，便能得到一个有序序列。

赫夫曼树：
    基本介绍：
        给定n个权值作为n个节点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树；
        哈夫曼树是树带权路径长度最短的树，权值较大的节点离根较近。
    概念：
        路径和路径长度：在一棵树中，从一个节点往下可以达到的孩子或者孙子节点之间的通路称为路径。通路中分支的数目称为路径长度。
        若规定根节点的层数为1，则从根节点到L层节点的路径长度为L-1。
        节点的权：若将树中结点赋给一个有着某种含义的值，则这个数值称为该节点的权。
        节点的带权路径长度：从根节点到该节点之间的路径长度与该节点权的乘积。
        树的带权路径长度：树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为WPL，权值越大的节点离根节点越近的二叉树才是最优二叉树。
        WPL最小的就是赫夫曼树。
    步：骤：
        1.从小到大进行排序，将每一个数据创建为一个节点，每个节点可以看成是简单的二叉树；
        2.取出根节点权值最小的两颗二叉树，组成一颗新的二叉树，该新的二叉树根节点是前面两颗二叉树根节点权值的和；
        3.再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3的步骤，直到数列中所有的数据被处理，就得到一颗赫夫曼树。

赫夫曼编码：因为赫夫曼树是最优的权值路径树，所以可以用来压缩
    最佳实践：文件压缩-文件解压
    注意事项：
        1.如果文件本身就是经过压缩处理的，那么使用赫夫曼编码在压缩效率不会有明显的变化，比如视频、ppt等
        2.赫夫曼编码是按字节来处理的，因此可以处理所有的文件
        3.如果一个文件中的内容，重复的内容不多，压缩效果也不会很明显

二叉排序树：
    特征：
        左节点<父节点<右节点；
        如果存在重复元素添加，那么相当于修改，比如hashMap的put方法，底层是 数组+红黑树(二叉排序树) key就不能重复
    增删改查：
        增/改：判断元素值，相等就去修改
            小于继续判断左节点，左节点为空，添加，否则继续判断左节点的节点(递归);
            大于继续判断右节点，右节点为空，添加，否则继续判断右节点的节点(递归);
        查/遍历：中序遍历/判断就行
        删：比较麻烦，重中之重！！！主要是三种情况删除：
            1.删除节点为叶子节点：直接用父节点删除就行
            2.删除节点只有左节点或者右节点： 2*2=4种判断
                要判断父节点是否为空，有可能是删除根节点，那么就不用这么麻烦，直接根节点=左节点或者右节点
                否则再判断该节点是父节点的左节点还是右节点：如果为左节点那么父左节点直接连接该节点的左节点或者右节点；如果为右节点那么父右节点直接连接该节点的左节点或者右节点
            3.删除节点为节点树，使用替换的思路：该节点右节点的最小节点值替换该节点，删除最小节点
        public void del(int value) {
            // root为空不删除
            if (root == null) {
                return;
            }
            // 二叉排序树没有该节点，不删除
            BinarySortNode binarySortNode = search(value);
            if (binarySortNode == null) {
                return;
            }
            // 只有根节点
            if (root.getLeft() == null && root.getRight() == null) {
                root = null;
                return;
            }
            // 查找父节点
            BinarySortNode parent = searchParent(value);
            // 删除叶子节点 找到叶子节点就可以直接删除
            if (binarySortNode.getLeft() == null && binarySortNode.getRight() == null) {
                if (parent.getLeft() != null && parent.getLeft().getValue() == value) {
                    parent.setLeft(null);
                    return;
                }
                if (parent.getRight() != null && parent.getRight().getValue() == value) {
                    parent.setRight(null);
                    return;
                }
            }
            // 该节点既有左节点又有右节点
            if (binarySortNode.getLeft() != null && binarySortNode.getRight() != null) {
                // 注意：因为不会存在该节点的右子节点下的最小值节点小于该值，所以只需要将该节点的值改为右子节点下的最小节点的值(相当于替换了)，将最小节点的值删除，此时还是二叉排序树
                int min = delRightTreeMin(binarySortNode.getRight());
                binarySortNode.setValue(min);
                return;
            }
            // 此时只剩下一种情况：左节点不为空或者右节点不为空  删除子节点 节点只有一个子节点
            // 如果只有左子节点
            if (binarySortNode.getLeft() != null) {
                // 如果根节点就挂了一个左节点，此时删除根节点的时候根节点父类为空会报空指针异常
                if (parent != null) {
                    // 将父节点的左节点直接连接该节点的左节点
                    if (parent.getLeft() != null && parent.getLeft().getValue() == value) {
                        parent.setLeft(binarySortNode.getLeft());
                        return;
                    }
                    // 将父节点的右节点直接连接该节点的左节点
                    // 注意：不会存在该节点的左子节点下的最大值节点大于该值，因为是添加的时候就进行判断了，所以可以直接连接
                    if (parent.getRight() != null && parent.getRight().getValue() == value) {
                        parent.setRight(binarySortNode.getLeft());
                        return;
                    }
                } else {
                    root = binarySortNode.getLeft();
                }
                // 只有右节点
            } else {
                // 如果根节点就挂了一个右节点，此时删除根节点的时候根节点父类为空会报空指针异常
                if (parent != null) {
                    // 将父节点的左节点直接连接该节点的右节点
                    // 注意：不会存在该节点的右子节点下的最小值节点小于该值，因为是添加的时候就进行判断了，所以可以直接连接
                    if (parent.getLeft() != null && parent.getLeft().getValue() == value) {
                        parent.setLeft(binarySortNode.getRight());
                        return;
                    }
                    // 将父节点的右节点直接连接该节点的右节点
                    if (parent.getRight() != null && parent.getRight().getValue() == value) {
                        parent.setRight(binarySortNode.getRight());
                        return;
                    }
                } else {
                    root = binarySortNode.getRight();
                }
            }
        }